{
  "posts": [
    {
      "id": 20,
      "title": "제목 20 기여하는 방법",
      "desc": "React는 페이스북 최초 오픈소스 프로젝트 중 하나로 매우 활발히 개발하고 있으며 facebook.com의 모든 사용자에게 전달되고 있습니다. 이 프로젝트에 최대한 쉽고 간편하게 기여할 수 있도록 노력하고 있지만, 아직 부족한 상태입니다. 이 문서를 통해 여러분이 프로젝트에 기여하는 절차에 대해 명확하게 인지하고 궁금한 점들을 해결할 수 있기를 바랍니다."
    },
    {
      "id": 19,
      "title": "제목 19 동시성",
      "desc": "위의 두 가지 예시를 살펴보고 Concurrent 모드가 어떻게 통합되는지 살펴보겠습니다. Concurrent 모드에서 React는 여러 작업을 동시에, 다른 팀원들이 각자 작업을 할 수 있는 브랜치처럼, 진행할 수 있습니다."
    },
    {
      "id": 18,
      "title": "제목 18 의도적인 로딩 시퀀스",
      "desc": "Concurrent 모드는 “브랜치에서” 하는 React 작업과 같다고 전에 말했습니다. 브랜치는 단기적인 수정을 할 때뿐만 아니라 장기적인 실행 기능에도 유용합니다. 때로는 기능에 대해 작업을 할 수도 있습니다. 하지만 마스터로 병합할 수 있는 “적합한 state”가 되기까지 몇 주가 걸릴 수 있습니다. 버전 관리의 이러한 측면은 렌더링에도 적용됩니다."
    },
    {
      "id": 17,
      "title": "제목 17 인터럽트 가능한 렌더링",
      "desc": "필터링 가능한 제품 목록을 생각해보세요. 목록 필터에 입력하고 모든 키를 누를 때마다 버벅거림을 느낀 적이 있나요? 제품 목록을 업데이트하는 몇몇 작업은 불가피할 수 있습니다. (예를 들어, 새로운 DOM 노드를 만들거나 레이아웃을 수행하는 브라우저를 만드는 작업) 그러면, 언제 어떻게 이런 비중 있는 작업을 수행할까요?"
    },
    {
      "id": 16,
      "title": "제목 16 차단 vs 인터럽트 렌더링",
      "desc": "Concurrent 모드를 설명하기 위해서 버전 관리를 예를 들어 설명할 것입니다 팀에서 일하고 있다면 Git과 같은 버전 관리 시스템을 사용하며 브랜치로 작업할 것입니다. 브랜치가 준비된다면 다른 사람들이 해당 작업을 가져올 수 있도록 작업을 마스터 브랜치로 병합 할 수 있습니다."
    },
    {
      "id": 15,
      "title": "제목 15 Custom Hook",
      "desc": "개발을 하다 보면 가끔 상태 관련 로직을 컴포넌트 간에 재사용하고 싶은 경우가 생깁니다. 이 문제를 해결하기 위한 전통적인 방법이 두 가지 있었는데, higher-order components와 render props가 바로 그것입니다. Custom Hook은 이들 둘과는 달리 컴포넌트 트리에 새 컴포넌트를 추가하지 않고도 이것을 가능하게 해줍니다."
    },
    {
      "id": 14,
      "title": "제목 14 Effect Hook",
      "desc": "React 컴포넌트 안에서 데이터를 가져오거나 구독하고, DOM을 직접 조작하는 작업을 이전에도 종종 해보셨을 것입니다. 우리는 이런 모든 동작을 “side effects”(또는 짧게 “effects”)라고 합니다. 왜냐하면 이것은 다른 컴포넌트에 영향을 줄 수도 있고, 렌더링 과정에서는 구현할 수 없는 작업이기 때문입니다."
    },
    {
      "id": 13,
      "title": "제목 13 State Hook",
      "desc": "여기서 useState가 바로 Hook 입니다(이게 무슨 의미인지는 앞으로 알아보겠습니다). Hook을 호출해 함수 컴포넌트(function component) 안에 state를 추가했습니다. 이 state는 컴포넌트가 다시 렌더링 되어도 그대로 유지될 것입니다. useState는 현재의 state 값과 이 값을 업데이트하는 함수를 쌍으로 제공합니다. 우리는 이 함수를 이벤트 핸들러나 다른 곳에서 호출할 수 있습니다. 이것은 class의 this.setState와 거의 유사하지만, 이전 state와 새로운 state를 합치지 않는다는 차이점이 있습니다. (useState와 this.state를 비교하는 예시가 Using the State Hook 문서에 있으니 한번 보세요.)"
    },
    {
      "title": "테스트 제목",
      "desc": "테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다. 테스트 글입니다.",
      "id": 1618210695400
    },
    {
      "title": "dsdf",
      "desc": "1212",
      "id": 1618218027584
    }
  ],
  "me": {
    "id": "heroyooi",
    "name": "성연욱",
    "age": 37
  }
}