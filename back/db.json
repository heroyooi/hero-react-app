{
  "posts": [
    {
      "id": 20,
      "title": "제목 20 기여하는 방법",
      "desc": "React는 페이스북 최초 오픈소스 프로젝트 중 하나로 매우 활발히 개발하고 있으며 facebook.com의 모든 사용자에게 전달되고 있습니다. 이 프로젝트에 최대한 쉽고 간편하게 기여할 수 있도록 노력하고 있지만, 아직 부족한 상태입니다. 이 문서를 통해 여러분이 프로젝트에 기여하는 절차에 대해 명확하게 인지하고 궁금한 점들을 해결할 수 있기를 바랍니다."
    },
    {
      "id": 19,
      "title": "제목 19 동시성",
      "desc": "위의 두 가지 예시를 살펴보고 Concurrent 모드가 어떻게 통합되는지 살펴보겠습니다. Concurrent 모드에서 React는 여러 작업을 동시에, 다른 팀원들이 각자 작업을 할 수 있는 브랜치처럼, 진행할 수 있습니다."
    },
    {
      "id": 18,
      "title": "제목 18 의도적인 로딩 시퀀스",
      "desc": "Concurrent 모드는 “브랜치에서” 하는 React 작업과 같다고 전에 말했습니다. 브랜치는 단기적인 수정을 할 때뿐만 아니라 장기적인 실행 기능에도 유용합니다. 때로는 기능에 대해 작업을 할 수도 있습니다. 하지만 마스터로 병합할 수 있는 “적합한 state”가 되기까지 몇 주가 걸릴 수 있습니다. 버전 관리의 이러한 측면은 렌더링에도 적용됩니다."
    },
    {
      "id": 17,
      "title": "제목 17 인터럽트 가능한 렌더링",
      "desc": "필터링 가능한 제품 목록을 생각해보세요. 목록 필터에 입력하고 모든 키를 누를 때마다 버벅거림을 느낀 적이 있나요? 제품 목록을 업데이트하는 몇몇 작업은 불가피할 수 있습니다. (예를 들어, 새로운 DOM 노드를 만들거나 레이아웃을 수행하는 브라우저를 만드는 작업) 그러면, 언제 어떻게 이런 비중 있는 작업을 수행할까요?"
    },
    {
      "id": 16,
      "title": "제목 16 차단 vs 인터럽트 렌더링",
      "desc": "Concurrent 모드를 설명하기 위해서 버전 관리를 예를 들어 설명할 것입니다 팀에서 일하고 있다면 Git과 같은 버전 관리 시스템을 사용하며 브랜치로 작업할 것입니다. 브랜치가 준비된다면 다른 사람들이 해당 작업을 가져올 수 있도록 작업을 마스터 브랜치로 병합 할 수 있습니다."
    },
    {
      "id": 15,
      "title": "제목 15 Custom Hook",
      "desc": "개발을 하다 보면 가끔 상태 관련 로직을 컴포넌트 간에 재사용하고 싶은 경우가 생깁니다. 이 문제를 해결하기 위한 전통적인 방법이 두 가지 있었는데, higher-order components와 render props가 바로 그것입니다. Custom Hook은 이들 둘과는 달리 컴포넌트 트리에 새 컴포넌트를 추가하지 않고도 이것을 가능하게 해줍니다."
    },
    {
      "id": 14,
      "title": "제목 14 Effect Hook",
      "desc": "React 컴포넌트 안에서 데이터를 가져오거나 구독하고, DOM을 직접 조작하는 작업을 이전에도 종종 해보셨을 것입니다. 우리는 이런 모든 동작을 “side effects”(또는 짧게 “effects”)라고 합니다. 왜냐하면 이것은 다른 컴포넌트에 영향을 줄 수도 있고, 렌더링 과정에서는 구현할 수 없는 작업이기 때문입니다."
    },
    {
      "id": 13,
      "title": "제목 13 State Hook",
      "desc": "여기서 useState가 바로 Hook 입니다(이게 무슨 의미인지는 앞으로 알아보겠습니다). Hook을 호출해 함수 컴포넌트(function component) 안에 state를 추가했습니다. 이 state는 컴포넌트가 다시 렌더링 되어도 그대로 유지될 것입니다. useState는 현재의 state 값과 이 값을 업데이트하는 함수를 쌍으로 제공합니다. 우리는 이 함수를 이벤트 핸들러나 다른 곳에서 호출할 수 있습니다. 이것은 class의 this.setState와 거의 유사하지만, 이전 state와 새로운 state를 합치지 않는다는 차이점이 있습니다. (useState와 this.state를 비교하는 예시가 Using the State Hook 문서에 있으니 한번 보세요.)"
    },
    {
      "id": 12,
      "title": "제목 12 Hook의 개요",
      "desc": "Hook이 React 버전 16.8에 새로 추가되었습니다. Hook을 이용하여 Class를 작성할 필요 없이 상태 값과 여러 React의 기능을 사용할 수 있습니다."
    },
    {
      "id": 11,
      "title": "제목 11 외부 플러그인을 사용하는 컴포넌트",
      "desc": "React는 유연하며 다른 라이브러리나 프레임워크를 함께 활용할 수 있습니다. 이 예제에서는 외부 마크다운 라이브러리인 remarkable을 사용해 <textarea>의 값을 실시간으로 변환합니다."
    },
    {
      "id": 10,
      "title": "제목 10 애플리케이션",
      "desc": "props와 state를 사용해서 간단한 Todo 애플리케이션을 만들 수 있습니다. 이 예제에서는 state를 사용해 사용자가 입력한 텍스트와 할 일 목록을 관리합니다. 이벤트 핸들러들이 인라인으로 각각 존재하는 것처럼 보이지만, 실제로는 이벤트 위임을 통해 하나로 구현됩니다."
    },
    {
      "id": 9,
      "title": "제목 9 상태를 가지는 컴포넌트",
      "desc": "컴포넌트는 this.props를 이용해 입력 데이터를 다루는 것 외에도 내부적인 상태 데이터를 가질 수 있습니다. 이는 this.state로 접근할 수 있습니다. 컴포넌트의 상태 데이터가 바뀌면 render()가 다시 호출되어 마크업이 갱신됩니다."
    },
    {
      "id": 8,
      "title": "제목 8",
      "desc": "React를 사용하기 위해서 JSX가 꼭 필요한 것은 아닙니다. JSX를 컴파일한 JavaScript 코드를 확인하려면 Babel REPL을 이용해보세요."
    },
    {
      "id": 7,
      "title": "제목 7",
      "desc": "React 컴포넌트는 render()라는 메서드를 구현하는데, 이것은 데이터를 입력받아 화면에 표시할 내용을 반환하는 역할을 합니다. 이 예제에서는 XML과 유사한 문법인 JSX를 사용합니다. 컴포넌트로 전달된 데이터는 render() 안에서 this.props를 통해 접근할 수 있습니다."
    },
    {
      "id": 6,
      "title": "제목 6",
      "desc": "React는 Node 서버에서 렌더링을 할 수도 있고, React Native를 이용하면 모바일 앱도 만들 수 있습니다."
    }
  ],
  "me": {
    "id": "heroyooi",
    "name": "성연욱",
    "age": 37
  }
}